---
layout: post
category : 笔记
tags : [Java]
---
{% include JB/setup %}

#### 1. 基本概念

1. java中integer和boolean两种类型不相容，因此不能写

		int x = 1;
		while (x) {}

2. println会在最后插入换行，print不会.
3. String [] lst = ["a", "b"]; lst.length;
4. Math.random() 随机产生[0,1]之间的小数
5. int x = (int) 24.6;
6. +: 连接字符串
7. 面向对象优点：有时不需要改动已经测试号的程序。
8. 创建对象需要两个类：一个是被操作的类（比如Dog, AlarmClock等），另一个是测试该类的类。测试用的类带有main()，在其中建立存取被测对象。

		class Dog{}
		class DogTestDrive{}
		
9. java主动管理内存
10. 全局变量：任何变量只要加上public，static, final，基本上都会变成全局变量取用的常数。
11. 数量庞大的个别文件，可以pkzip存档为Java Archive-.jar文件。在jar文件中可以引入一个简单的文件，manifest，里面定义jar中哪个文件带有应用程序的main()方法。
12. 所有的java程序都定义在类中。
13. 创建类时，同时创建独立的测试用的类。
14. Java很注重类型。必须声明所有变量的类型。
15. 变量有两种：primitive主数据类型用来保存基本类型的值，包括整数，布尔，浮点数; 对象引用保存的是对象的引用（？？）
16. 变量必须要有类型，必须要有名称。
17. primitive主数据类型：

		布尔：boolean true/false
		char: 16 bits 
		整型：byte（8位二进制）short(16位) int(32位) long（64位）
		浮点：float(32位) double(64位)  
18. float f = 32.5f;除非加上"f"，否则小数都会被java当作double处理。
19. 确保变量能存下保存的值。
20. 命名规则：
	* 名称必须以字母，下划线，$开头，不能以数字开头
	* 除了第一个字符外，后面就可以用数字，反正不要用在第一个字符就行。
	* 避开Java保留字。
21. 对primitive主数据类型的变量来说，变量值就是所代表的值。对`引用`变量来说，变量值是取得特定对象的位表示法。
22. 引用大小未知；对任意一个Java虚拟机来说，所有的引用大小都一样；不能对引用变量运算。
23. primitive主数据类型变量值是该值的字节所表示的；引用变量的值代表位于堆之对象的存取方法。引用变量如同遥控器。没有引用到任何对象的引用变量的值位null值。
24. 数组一定是对象。
25. 类描述的是对象知道什么与执行什么
26. 方法运用形参，调用方传入实参
27. java是通过值传递的，通过拷贝传递
28. 可以忽略方法的返回值
29. 如何隐藏数据？使用公有，私有修饰符。将实例变量标记为私有，提供公有gettet,setter控制存取。
30. 实例变量永远都有默认值:整数0，浮点0.0，布尔false，引用变量null
31. null表示没有操作对象的远程控制，是引用不是对象
32. 实例变量声明在类内，而不是方法内。局部变量声明在方法中。局部变量在使用前必须初始化，没有默认值。
33. equals和==的区别 
	* 当参数引用的对象与当前对象为同一对象时，“==“ 和 ”equals” 均为true。
	* 如果两个对象的类型一致，并且内容一致，则“equals”返回true,这些类有：
java.io.file,java.util.Date,java.lang.string,包装类（Integer,Double等）
		
			Animal  animal1=new Dog();
			Animal  animal2=new  Cat();
			Animal animal3=animal1;
		    则animal1==animal2   (FALSE)
			animal1.equals(animal2)  (false)
		    animal1==animal3   (true)
		    animal1.equals(animal3)   (true)
			
			Integer int1=new Integer(1);
			Integer int2=new Integer(1);
			String str1=new String("hello");
			String str2=new String("hello");
			int1==int2   输出：false,因为不同对象
			int1.equals(int2)   输出：TRUE
			str1==str2   (false)
			str1.equals(str2)   (true)

34. ArrayList.remove 
		
		remove(int index) 移除下标为index的元素，返回移除的元素。
		remove(object o) 移除元素o,返回true/false
35. 伪码--测试码--真实码
36. 伪代码记录要做什么，而不是怎么做
37. 开始编写代码之前，先学出测试方法用的代码。
38. 极限编程（XP）方法论
39. 思考与编写测试代码有助于了解被测试程序应该要做哪些事情。
40. Integer.parseInt("3");只对string为数字是有用。
41. for(int cell: locationCells){}
42. x++; ++x;
43. int randomNum = (int)(Math.random()*8);
44. ArrayList：Java函数库的一个类，可变的。
45. ArrayList无法保存primitive主数据类型。

	不能保存int, float, 等primitive等数据类型，不过可以使用Integer等。

46. 布尔表达式：且（&&）或(||)非（!）
47. &,| 与&&, ||的区别？&和| 是可以用做逻辑运算也可以用做位运算。
	* 运算数据类型支持不同：&&,||只支持布尔类型运算；&,|可以支持int, boolean,char三种类型。
	* 逻辑运算不同：&&,||条件运算符;&，|无条件运算符。

    计算p1&&p2时,Java先计算p1,若p1为true再计算p2;若p1为false,则不再计算P2,因此&&又称为条件与运算符.而&的两个运算对象都要计算,所以,&又称为无条件与运算符.类似的还有 "|| " (条件或运算符,p1 || p2,Java先计算p1,若p1为FALSE再计算P2,若P1为TRUE,则不再计算P2)和 "| " (无条件运算符,两边对象都要计算) .
  
    例如:(a <2)&(b-- <2) 保证(b-- <2)能被计算.这样,无论a是否小于2,变量b都要减1.

    要避免使用&和|运算符,它们好处不大.使用&和|运算符会使程序可读性降低,并且可能导致错误,比如:(x!=0)&(100/x)当x为0时产生运行错误,而(x!=0)&&(100/x)没问题
48. java程序不会因为import而变大变慢
49. 除了java.lang这个包里的类，要用到其他的类都要指定完整名称。

#### 7. 继承与多态
1. 继承和包含的关系：is-a测试。
2. super 可指定使用父类的方法。
3. 父类通过存取权限限制子类是否可继承某些特定成员。
	* private: 不可继承
	* default
	* protected
	* public : 可继承
4. 滥用继承了吗，什么时候使用继承
	* 当某个子类比父类更有特定意义时
	* 当行为程序应该被多个相同基本类型所共享时
	* is-a测试通过
5. 子类是extends父类出来的
6. 子类会继承父类所有public类型的实例变量和方法，但不继承所有的private类型的变量方法
7. 继承下来的方法可以被覆盖，但实例变量不能被覆盖，因为实例变量不能定义行为。
8. is-a测试是单向的，具有传递性。
9. java只是由一堆类组成的。
10. 多态性：发送消息给某个对象，让该对象自行决定响应何种行为。
    * 通过将子类对象引用赋值给超类对象引用变量来实现动态方法调用。
    * java 的这种机制遵循一个原则：当超类对象引用变量引用子类对象时，**被引用对象的类型**而不是引用变量的类型决定了调用谁的成员方法，但是这个被调用的方法必须是在超类中定义过的，也就是说被子类覆盖的方法。 
11. 方法的重写**Overriding**和重载**Overloading**是Java多态性的不同表现。重写Overriding是父类与子类之间多态性的一种表现，重载Overloading是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写(Overriding)。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被“屏蔽”了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型，则称为方法的重载(Overloading)。Overloaded的方法是可以改变返回值的类型。
12. 实际上这里涉及方法调用的优先问题 ，优先级由高到低依次为：
    
        this.show(o) > super.show(o) >
        this.show((super)o) > super.show((super)o)
13. 子类层次限制：一般不超过一，两层。也有例外，特别是GUI类这边。
14. 没有私有类概念，不过有办法防止某个类被作出子类：
	* 存取控制：类不标注为公有。非公有类智能被同一个包的类作出子类。
	* final修饰符：表示为继承树的末端，不能被继承。
	* 让类只拥有private的构造程序。
15. 防止特定方法被覆盖，将该方法标注为final。将整个类标注为final，表示没有任何方法被覆盖。
16. 方法是合约的标志。
17. 覆盖的方法参数必须一样，且返回类型必须兼容。
18. 子类覆盖父类方法，覆盖规则：
	* 参数必须一样，且返回类型要兼容。参数不一样则不是覆盖，是overload
	* 不能降低方法的存取权限。父类是public，子类不能是private。
19. 重载(overload)的意义是两个方法，名称相同，参数不同。**重载和继承，多态毫无关系**。重载方法和覆盖方法不一样。
	* 重载返回类型可以不同。
	* 不能只是返回类型不同而参数相同。
	* 可以修改存取权限。

#### 8.接口与抽象类
1. abstract: 通过标记类位abstract，则不管在哪里，这个类就不能创建任何类型的实例。

	    abstract class Canine extends Animal{
	    	public void roam() {}
	    }
2. 抽象类除了被继承过之外，没有用途，没有值，没有目的。
3. 抽象类表示此类必须被extend过，抽象的方法表示该方法一定被覆盖过override
4. 抽象的方法没有实体
5. 如果声明了一个抽象的方法，必须将类标记为抽象类。不能在非抽象类中拥有抽象方法。
6. 抽象方法的意义：
	* 就算无法实现出方法的内容，还是可以定义出一组子型共同的协议。
	* 支持多态
7. 抽象方法没有内容，只是为了标记出多态存在。
8. 必须实现所有的抽象的方法。
9. 

#### 9.构造器与垃圾收集器

#### 10.数字局静态

#### 11.异常处理

#### 12.图形用户接口

#### 13.Swing

#### 14.序列化和文件的输入输出

#### 15.网络与线程

#### 16.集合与泛型

#### 17.包，jar存档文件和部署

#### 18.远程部署RMI



### 书籍推荐

1. 《Head First 设计模式》
2. 《极限编程》




